# The following is an implementation of an differential flatness
# based controller. The trajectory is obtained from trajGen3D.py
# which used 7th order polynomial. The reference trajectory for all
# states and inputs is computed by dif_flat.py. Then and LQR 
# controller is used to make the quadrotor follow the reference trajectory
# generated by the differential flatness script.


# TODO:  - Finaliz uc calculation following state-space control formality
#        - Recalculate for ZXY eular rotation convention

import numpy as np
import model.params as params
from math import sin, cos

import dif_flat as dfl
import gains
from utils.utils import RPYToRot_ZYX

# LQR Translational gains and reference input matrices
Kt = np.matrix([10., 4.5825])
Nu_t = np.matrix([0.0])
Nx_t = np.matrix([[1.0],[0.0]])



# LQR Rotational gains
Kr = 2.23606
Nu_r = 0.0
Nx_r = 1.0

Kp = np.diag([gains.Kpx2, gains.Kpy2, gains.Kpz2])
Kd = np.diag([gains.Kdx2, gains.Kdy2, gains.Kdz2])
Ki = np.diag([gains.Kix2, gains.Kiy2, gains.Kiz2])

def run(quad, des_state):

    # obtain desired state
    # this state *must* be from a C4 differentiable trajectory
    pos_traj = des_state.pos
    vel_traj = des_state.vel
    acc_traj = des_state.acc
    jerk_traj = des_state.jerk 
    snap_traj = des_state.snap 
    yaw_traj = des_state.yaw
    yaw_dot_traj = des_state.yawdot
    yaw_ddot_traj = des_state.yawddot

    # pack everything into a point of a desired trajectory
    trajectory = [pos_traj, vel_traj, acc_traj, jerk_traj, snap_traj, yaw_traj, yaw_dot_traj, yaw_ddot_traj]

    # compute reference states and inputs from desired trajectory
    ref_ = dfl.compute_ref(trajectory)
    #print(ref_)

    # extract each reference state and inputs
    pos_ref = np.array(ref_[0])
    v_ref = np.array(ref_[1])
    or_ref = np.array(ref_[2])
    w_ref = np.array(ref_[3])
    Rbw_ref = np.array(ref_[6])
    w_dot_ref = np.array(ref_[5])
    #print("w_dot_ref: {}".format(w_dot_ref.flatten()))

    # get drone state
    pos = quad.position().reshape(3,1)
    v = quad.velocity().reshape(3,1)
    or_ = quad.attitude().reshape(3,1)
    Rwb = RPYToRot_ZYX(or_[0][0], or_[1][0], or_[2][0])
    Rbw = Rwb.T
    phi, theta, psi = dfl.RotToRPY_ZYX(Rbw)
    w = quad.omega().reshape(3,1)
    #print(pos)

    #pos = np.array([[x],[y],[z]])
    #v = np.array([[vx_r],[vy_r],[vz_r]])

    # ------------------------ #
    #  Compute thrust
    # ------------------------ #
    
    ua_e = -1.0*np.dot(Kp,pos-pos_ref) -1.0*np.dot(Kd,v-v_ref) #-1.0*np.dot(Ki,self.pos_err)  # PID control law
    
    ua_ref = np.array(ref_[4])

    ua = ua_e + ua_ref

    e_3 = np.array([[0.0],[0.0],[1.0]])  # this is z axis of body expressed in body frame
    Z_w = np.array([[0.0],[0.0],[1.0]])  # the Z axis of world frame expressed in body frame is equal to Z_b...
    wzb = np.dot(Rbw, e_3)

    F = params.mass*np.dot(wzb.T, (ua + params.g*Z_w))[0][0]

    # ------------------------ #
    #  Compute desired orientation
    # ------------------------ #
    zb_des = (ua + params.g*Z_w)/np.linalg.norm(ua + params.g*Z_w)
    yc_des = np.array(dfl.get_yc(or_ref[2][0]))   #transform to np.array 'cause comes as np.matrix
    xb_des = np.cross(yc_des, zb_des, axis=0)
    xb_des = xb_des/np.linalg.norm(xb_des)
    yb_des = np.cross(zb_des, xb_des, axis = 0)
    Rbw_des = np.concatenate((xb_des, yb_des, zb_des), axis=1)

    # ------------------------ #
    #  Compute desired angular velocity
    # ------------------------ #    
    w_des = get_wdes(Rbw, Rbw_des, Rbw_des, w_ref)
    #print(">> Wdes: {}".format(np.linalg.norm(w_des)))

    # ------------------------ #
    #  Compute control torque
    # ------------------------ # 
    K_omega = 0.17
    M = -K_omega*(w - w_des) + np.cross(w,np.dot(params.I,w_des), axis = 0) + np.dot(params.I, w_dot_ref)


    return F.item(0), M

def get_wdes(Rbw, Rbw_des, Rbw_ref_dot, w_ref):
    """
    Calculation of desired angular velocity. See:

    Pucci, D., Hamel, T., Morin, P., & Samson, C. (2014). 
    Nonlinear Feedback Control of Axisymmetric Aerial Vehicles
    https://arxiv.org/pdf/1403.5290.pdf

    Kai, J. M., Allibert, G., Hua, M. D., & Hamel, T. (2017). 
    Nonlinear feedback control of Quadrotors exploiting First-Order Drag Effects. 
    IFAC-PapersOnLine, 50(1), 8189-8195. https://doi.org/10.1016/j.ifacol.2017.08.1267
    """

    # Thrust direction is the body Z axis
    e3 = np.array([[0.0],[0.0],[1.0]])

    # extract real and desired body Z axis
    zb = np.dot(Rbw,e3)
    zb_r = np.dot(Rbw_des,e3)
    zb_r_dot = np.dot(Rbw_ref_dot, e3)

    # Calculation of desired angular velocity is done by 3 terms: an error (or feedback) term,
    # a feed-forward term and a term for the free degree of freedom of rotation around Z axis (Yaw)

    # Feedback term calculation
    k10 = 5.0
    epsilon = 0.01
    k1 = k10/(1.0 + np.dot(zb.T, zb_r)[0][0] + epsilon)
    lambda_dot = 0.0
    lambda_ = 5.0
    w_fb = (k1 + lambda_dot/lambda_)*np.cross(zb, zb_r, axis= 0)

    # Feed-forward term calculation
    w_ff = 0.0*np.cross(zb_r, zb_r_dot, axis = 0)  #np.array([[0.0],[0.0],[0.0]])

    # Yaw rotation
    w_yaw = 0.0*np.dot(w_ref.T, zb)[0][0] * zb   # np.array([[0.0],[0.0],[0.0]])

    # Convert to body frame
    w_in = np.dot(Rbw.T,w_fb + w_ff + w_yaw)

    return w_in