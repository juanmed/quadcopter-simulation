# The following is an implementation of an differential flatness
# based controller. The trajectory is obtained from trajGen3D.py
# which used 7th order polynomial. The reference trajectory for all
# states and inputs is computed by dif_flat.py. Then and LQR 
# controller is used to make the quadrotor follow the reference trajectory
# generated by the differential flatness script.


import numpy as np
import model.params as params
from math import sin, cos

import dif_flat as dfl
from utils.utils import RPYToRot, RPYToRot2

# LQR Translational gains and reference input matrices
Kt = np.matrix([3.162277, 2.70639])
Nu_t = np.matrix([0.0])
Nx_t = np.matrix([[1.0],[0.0]])



# LQR Rotational gains
Kr = 3.162277
Nu_r = 0.0
Nx_r = 1.0

def run(quad, des_state):

    # obtain desired state
    # this state *must* be from a C4 differentiable trajectory
    pos_traj = des_state.pos
    vel_traj = des_state.vel
    acc_traj = des_state.acc
    jerk_traj = des_state.jerk 
    snap_traj = des_state.snap 
    yaw_traj = des_state.yaw
    yaw_dot_traj = des_state.yawdot
    yaw_ddot_traj = des_state.yawddot

    # pack everything into a point of a desired trajectory
    trajectory = [pos_traj, vel_traj, acc_traj, jerk_traj, snap_traj, yaw_traj, yaw_dot_traj, yaw_ddot_traj]

    # compute reference states and inputs from desired trajectory
    ref_ = dfl.compute_ref(trajectory)
    #print(ref_)
    # extract each reference state and inputs
    x_r,y_r,z_r = ref_[0]
    vx_r,vy_r,vz_r = ref_[1]
    phi_r,theta_r,psi_r = ref_[2]
    p_r,q_r,r_r = ref_[3]


    # get drone state
    x, y, z = quad.position()
    x_dot, y_dot, z_dot = quad.velocity()
    phi, theta, psi = quad.attitude()
    p, q, r = quad.omega()



    # compute state error
    # state error = reference_state - drone_state
    #print("*** {} , {}".format(x_r,x))
    x_e = x_r.item(0) - x
    y_e = y_r.item(0) - y
    z_e = z_r.item(0) - z

    vx_e = vx_r.item(0) - x_dot
    vy_e = vy_r.item(0) - y_dot
    vz_e = vz_r.item(0) - z_dot

    phi_e = phi_r.item(0) - phi
    theta_e = theta_r.item(0) - theta
    psi_e = psi_r.item(0) - psi

    p_e = p_r.item(0) - p
    q_e = q_r.item(0) - q   
    r_e = r_r.item(0) - r

    """
    # compute error input
    ua_e_x = -1.0*Kt*np.matrix([[x_e],[vx_e]])
    ua_e_y = -1.0*Kt*np.matrix([[y_e],[vy_e]])
    ua_e_z = -1.0*Kt*np.matrix([[z_e],[vz_e]])
    ua_e = np.matrix([[ua_e_x.item(0)],[ua_e_y.item(0)],[ua_e_z.item(0)]])

    ub_e_x = -1.0*Kr*p_e
    ub_e_y = -1.0*Kr*q_e    
    ub_e_z = -1.0*Kr*r_e  
    ub_e = np.matrix([[ub_e_x],[ub_e_y],[ub_e_z]])

    uc_e_x = -1.0*Kr*phi_e
    uc_e_y = -1.0*Kr*theta_e
    uc_e_z = -1.0*Kr*psi_e
    uc_e = np.matrix([[uc_e_x],[uc_e_y],[uc_e_z]])
    """
    # In general    u = -K*x + (N_u + K*N_x)*r
    # r = reference state
    # x = state
    # K = LQR gains
    # N_u, N_x = refrence input and reference state matrices

    
    x_state = np.matrix([[x],[x_dot]])
    ua_e_x = -Kt*x_state + (Nu_t + Kt*Nx_t)*x_r

    y_state = np.matrix([[y],[y_dot]])
    ua_e_y = -Kt*y_state + (Nu_t + Kt*Nx_t)*y_r

    z_state = np.matrix([[z],[z_dot]])
    ua_e_z = -Kt*z_state + (Nu_t + Kt*Nx_t)*z_r
    ua_e = np.matrix([[ua_e_x.item(0)],[ua_e_y.item(0)],[ua_e_z.item(0)]])

    #wx_state = np.matrix([[z],[z_dot]])
    ub_e_x = -Kr*p + (Nu_r + Kr*Nx_r)*p_r.item(0)
    ub_e_y = -Kr*q + (Nu_r + Kr*Nx_r)*q_r.item(0)   
    ub_e_z = -Kr*r + (Nu_r + Kr*Nx_r)*r_r.item(0) 
    ub_e = np.matrix([[ub_e_x],[ub_e_y],[ub_e_z]])

    uc_e_x = -1.0*Kr*phi_e
    uc_e_y = -1.0*Kr*theta_e
    uc_e_z = -1.0*Kr*psi_e
    uc_e = np.matrix([[uc_e_x],[uc_e_y],[uc_e_z]])    
    

    # compute inputs to system
    # u_s = u_e + u_r
    ua_s = ua_e + ref_[4]
    ub_s = ub_e + ref_[5]
    uc_s = uc_e + ref_[6]

    # Now apply the inverse function to obtain F and M  

    # First obtain F = Rbw*Z_b(m*ua_s +g*Z_w)
    R = np.matrix(RPYToRot(phi, theta, psi)) # this rotation is world to body frame
    #R = np.matrix(RPYToRot2(phi_r.item(0), theta_r.item(0), psi_r.item(0))) # this rotation is world to body frame

    #R = R.T  # I need body to world frame

    Z_b = np.matrix([[0.0],[0.0],[1.0]])  # this is z axis of body expressed in body frame
    Z_w = np.matrix([[0.0],[0.0],[1.0]])  # the Z axis of world frame expressed in body frame is equal to Z_b...
    F = (Z_b.T)*R*(params.mass*(ua_s + params.g*Z_w))

    # Now obtain moments
    omega = np.matrix([[p],[q],[r]])
    #omega = np.matrix([[p_r.item(0)],[q_r.item(0)],[r_r.item(0)]])

    Inertia = np.matrix(params.I)
    M = Inertia*ub_s + np.matrix(np.cross(omega,Inertia*omega, axis = 0))
    # convert to numpy array for it to work with the rest of the code
    M = np.array([[M.item(0)],[M.item(1)],[M.item(2)]])

    # overwrite
    #F = ref_[7]
    #M = ref_[8]
    #M = np.array([[M.item(0)],[M.item(1)],[M.item(2)]])

    #print(F.item(0))
    #print(M)
    #F = 1.0
    #M = np.array([[0.0],[0.0],[0.0]])
    return F.item(0), M